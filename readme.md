# 计算概论B迷宫大作业

## 一、代码说明

### （一）maze.py

maze.py包含迷宫存储、访问、生成和寻路的相关代码。如果直接运行，它会输出一个20*20的迷宫，并直接给出左上到右下的最短路径。

### （二）part1.py

part1.py是第一部分程序以及其调用入口。

示例：

`4 4`

输出：

`0 0 1 0`

`1 0 0 0`

`0 1 0 1`

`0 0 0 0`

### （三）part2.py

part2.py是第二部分程序以及其调用入口。

示例：

`4 4`

`0 1 0 0`

`0 0 0 1`

`0 1 0 0`

`0 0 1 0`

输出：

`(0,0)(1,0)(1,1)(1,2)(2,2)(2,3)(3,3)`

示例：

`4 4`

`0 1 0 0`

`0 1 0 0`

`0 1 1 0`

`0 0 1 0`

输出：

`No possible path!`

### （四）visualize.py及其延伸程序

visualize.py包含一个函数visualize，它输入一个迷宫maze.Maze，输出它的可视化图片PIL.Image。如果直接运行，它会直接生成一个100*100的二维迷宫，找出左上到右下的路径，生成图片并直接调用系统自带的图片查看器进行显示。   

part1-visualized.py和part2-visualized.py是part1和part2的可视化版本。注意，在弹出图片窗口之后，还会在控制台询问要把图片保存到哪里。

### （五）game.pyw

game.pyw使用了pygame对迷宫进行可视化。你可以不断生成任意你想要大小的**四维**迷宫，从中选取你想知道的两个点并找到它们之间的距离。你还可以通过鼠标自由地构造任何你脑海中的迷宫。详细介绍见第五部分。

### （六）mazeGeneratorCExtension.py及其附属文件

mazeGeneratorCExtension.py和一些dll文件的作用是辅助生成四维迷宫。这些程序的存在能够使四维迷宫的生成时间大幅缩短，尤其在运行game.pyw的时候表现得尤为明显。

这些辅助程序对二维或者三维迷宫的生成速度没有帮助。但是你可以给它扩充长度为1的一个维度，使得它变成四维，从而起到加速作用。

直接运行这个python程序没有任何效果。

**注意，所有程序一定要在code文件夹下运行，不要从外部导入part1或者part2，否则会报错ImportError。**

---

## 二、生成算法

首先让地图中充满了障碍；然后从起点开始，从身边选中一个障碍，把障碍变成通路；不断循环，直到最后形成迷宫。

应具备如下条件：

1. 挖掘的目标在你所在的位置旁边；

2. 挖掘的目标周围除了你所在的那个位置；其余地方全部是障碍。（保证任何位置到起点有且只有一条通路）

3. 如果成功挖掘了一个障碍，移动到这个新的地方并开始挖掘。（深搜）

4. 如果不存在合适的挖掘目标，后退。

当通路充满了几乎整个网格后，你会后退到起点。这个时候算法结束。

你可能注意到通路不一定包含终点，所以这只是一个粗略的介绍，有一些细节需要完善。

---

接下来看`Maze.generate`函数做了什么。

1. 它把地图用障碍物1填满。

2. 生成了一个`_MazeGenerator`对象并直接调用。其中生成对象的时候判断自己是否是四维迷宫，并试图导入DLL，用C语言代替python对迷宫进行循环挖掘，以提高效率。

3. `_MazeGenerator.__call__`调用了`_MazeGenerator.explore`函数。

4. 进入`explore`函数，首先确认自己是障碍(1)，而且自己周围除了自己的来源地（也就是上一次调用这个函数时，向`exploreHistory`列表中追加的地方），没有通路。然后把自己挖了。接下来进一步判断自己周围有没有合适的障碍，把合适的障碍放到targets列表中，随机访问`targets`中的元素，并以这个元素为中心，再一次调用explore函数。如果没有合适的障碍，`explore`函数结束，自然就回到了递归的上一级，也就相当于后退。

5. `_MazeGenerator.__call__`调用了`_MazeGenerator.makeDest`函数。`makeDest`函数从终点开始随机挖掘，挖到通路停止。由于迷宫主要部分全部有且只有一条路通向起点，因此这种情况能解决绝大部分路径不存在的情况。

6. `_MazeGenerator.__call__`调用了`_MazeGenerator.randRemove`函数。`randRemove`函数则是随机选择地图上一定比例的位置，并把这些地方的障碍挖掉。这样就有可能会形成回路，增加迷宫的复杂度。

一个技术细节：把递归拆成了一个循环和一个列表，以避免爆栈（是没有任何报错的那种，程序直接没了）。

---

## 三、寻路算法

构造一个前线作为推进基地，每次根据预期的路径长度选择其中一个进行探索，把前线不断向终点方向推进，直到它包含了终点为止。这样得到的路径一定是最短路径。具体过程如下：

1. 从前线中找到一个预期长度最短的点，作为这一轮扩张的推进基地；

2. 遍历推进基地周围的点。如果这个点还没有被探索过，记录走到这里的距离；如果这个点已经被探索过，比较两条路线的长短，使用其中较短的路径。

3. 记录这些点的上一个点是推进基地。

4. 把这些新的点加入前线；把现在的这个推进基地移出前线。

等到探索结束后，我们从终点就可以一步步回到起点，这就能获得中间走过的点的列表。

预期长度：走到这个点已经走过的路程，加上这个点到终点的1-范数。

在`_PathFinder`类中，

`history: dict[tuple, np.ndarray[int32]]`属性记录了为了走到这一个点，它的前一个点是什么；

`frontier: list[np.ndarray[int32]]`属性记录了当前的前线，其中frontier已经按照预期路径从短到长进行排序；

`costs: dict[tuple, int]`属性记录了从起点走到这个点需要走过多少距离。

---

## 四、Maze类

##### Maze类具有以下属性：

`data: np.ndarray[np.uint8]`这个数组存储了迷宫的数据。`0`表示可以经过的路，`1`表示不能经过的障碍。

`shape: tuple` 迷宫的形状。理论上可以用`self.data.shape`代替。

`dimension: int` 迷宫的维数。理论上可以用`len(self.data.shape)`代替。

`ticker: np.ndarray[np.int32]`一个一维数组，用于描述这个迷宫中的某个位置。

`directions: list[np.ndarray[np.int32]]` 所有可能的前进方向。这是一个一维数组列表，列举了所有可能的移动方向。二维情形下它的值为`[[1,0],[0,1],[-1,0],[0,-1]]`。

##### Maze类具有以下成员函数：

`__init__(data=..., shape=(4,4))->None: `给定迷宫数据或者形状，初始化迷宫。如果同时给定数据和形状，忽略形状。如果只给定形状，其数据为全`0`.

`__getitem__(ticker)->int:`给定一个数组，返回迷宫中对应位置的数据。

`__setitem__(ticker, value)->None:`给定一个数组，把迷宫中对应位置的数据改为value。

`__str__()->str:`把迷宫转换为字符串，行内用空格分割，行间用换行符分割。结尾没有换行符。如果是三维或者以上的迷宫，不会输出其中的内容。

`legalTicker(ticker)->bool:`返回数组对应的位置是否位于迷宫内。

`neighbors(ticker)->list[np.ndarray[np.int32]]:`给一个位置，返回它所有旁边的位置。

`deepcopy()->Maze:` 复制自身。

`generate()->None:`重新生成一个存在通路的迷宫。

`findpath(self, start=None, end=None)->list[tuple]:`给定两个位置，从中寻路。如果不给参数，默认从左上角到右下角寻路。返回路径上各点对应的坐标构成的列表。

---

## 五、关于game.pyw

实现了四维迷宫的生成和显示。当`w`和`z`长度均为`1`时，它退化为了二维迷宫。

使用方法：

1. 直接运行`game.pyw`，自动生成一个(20\*20\*2)大小的高维迷宫。

2. 使用鼠标左键点击地图上的点将其选中，再选一个点即自动从两个点之间开始寻路。

3. 使用鼠标滚轮，或者按下+/-按键，缩放地图。缩放中心和鼠标指针的位置密切相关。

4. 使用鼠标右键拖动地图，或者按下四个方向键，改变它在屏幕中的相对位置。按下F键使迷宫自动归位。

5. 使用I/J/K/L四个按键改变显示迷宫的Z和W坐标。这样你可以自由地选取四维迷宫中的任何一点。

6. 按下E键或者Edit按钮进入编辑模式。再次按下E键或者PathFind按钮退出编辑模式。（这里存在一个BUG，当你第一次用鼠标点击按钮的时候，会出现自动退出的情况。）

7. 在编辑模式下，使用鼠标左键点击地图上的点将其挖去，使用鼠标右键点击地图上的点放置障碍物。

8. 在编辑模式下，按下C键或者Clear按钮，清空整个地图中的全部障碍物。

9. 在编辑模式下，按下G键或者Generate按钮，重新随机生成迷宫。

10. 按下S键或者Settings按钮，进入设置模式，编辑整个地图的尺寸和维数。如果你不想保存修改，按下Discard按钮；如果希望保存修改，按下Save按钮。

11. 如果发现窗口未响应，属于正常现象，程序正在进行计算，无暇处理事件；但是如果窗口没有发生未响应但是仍然显示异常，尝试按下R键以强制刷新。

12. 支持文本输入。你需要做的是把所有的输入以part2部分的格式放在一个文本文件中，然后将文本文件拖入pygame窗口。请参考sample.txt。

13. img文件夹并非必要，可以删去，并不影响程序正常运行。

---

关于这些C拓展比如mazeGenerator.dll，我只知道它在我的电脑的环境下能够正常工作，也不知道在别的电脑上它还能不能正常工作，因为即使这部分坏了甚至没了，也顶多导致在game.pyw中生成迷宫异常缓慢，不会报错或者产生log.txt的报错记录。

$\mathrm{Coming\ \ S}\infty \mathrm{n}:$

1. 中文界面 and English instruction files; 

2. 把计算中的未响应界面做成鼠标狂点的小游戏。

3. 打包成可执行文件。

